##########################################################################################################################
#  Telus International 2019  Lisandro Antonio Rafaelano Colocho
#
#  This is a template to use in order to deploy apps into the cluster
#  We are going to use a deployment it is a controller.
#  BUT K8S supports other controllers 
#      - Replicaset
#      - ReplicationController
#      - StatefulSets
#      - DaemonSet
#      
############################################################################################################################
apiVersion: apps/v1  # https://kubernetes.io/blog/2019/07/18/api-deprecations-in-1-16/
kind: Deployment  # You should add the kind of object in our case a deployment that it is a controller, it will help us to update pods and replicasets objects.
metadata:
  name: glogger-audit-web-deployment
  # [START STRATEGY LABELS] 
  labels:
    name: glogger-audit-web-deployment
    type_component: webapp
    language: javascript
    owner: is_global_regional_application
    managed-by: jenkins
    environment: production
    region: global
  # [END STRATEGY LABELS]
spec:
  revisionHistoryLimit: 5  # In testing cluster
  #revisionHistoryLimit: 10  # In production Cluster
  replicas: 1  # how many pods will run
  # [START STRATEGY DEPLOYMENT]  
  strategy:    #  this is how Kubernetes does the release when there are new changes (enhancements), Please see : https://github.com/ContainerSolutions/k8s-deployment-strategies
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0
    type: Recreate
   # [END STRATEGY DEPLOYMENT] 
  # [START SELECTOR]  
  selector:
    matchLabels:
      name: glogger-audit-web-deployment
      environment: production
  # [END SELECTOR]
  template:
    metadata:
    # [START STRATEGY LABELS]
      labels:
        name: glogger-audit-web-deployment
        type_component: webapp
        language: javascript
        owner: is_global_regional_application
        managed-by: jenkins
        environment: production
        region: global
    # [END STRATEGY LABELS]  
    spec:
      nodeSelector:
        team: di-web
        owner: is
    # [END NODE AFFINITY PRODUCTION]                      
      containers:
        # docker images PATH, it could be ti-ca-infrastructure or ti-is-devenv-01 Please NEVER add external container registry in order to avoid security hole
        # Please refer to the format on the name.
      - image: gcr.io/ti-is-prodenv-01/is-glogger-audit:v1
      # - image: gcr.io/ti-is-prodenv-01/is-glogger-audit-manually:v1
        # use lower case and underscore to join with other word in container_name
        # It will be useful in order to identify the container if there are more than one in one POD
        name: glogger-audit 
        # [START ASSIGN RESOURCES]
        # This section we are going to assign cpu and memory resources to new container
        # Why do we do this ? if we will do that, we will help to scheduler process in k8s in order to facilite the scheduler task
        # Also this is like a  constraint in order to avoid overuse resource
        # please read the following resources in order to unsderstand it.
        # cpu : https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b
        # memory : https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9
        imagePullPolicy: Always
        lifecycle:
          postStart:
            exec:
              command: ["/bin/sh","-c","apt-get update && apt-get install -y ca-certificates; cp -v -f /etc/ssl/private/cert-telus/certificates_star_telusinternational_com.crt /usr/local/share/ca-certificates/star_telusinternational_com.crt; update-ca-certificates"]
        # livenessProbe:
        #   httpGet:
        #       # IMPORTANT this uri must return 200 status and keycloack security doesn't apply on that uri
        #       # kubelet will check if the app is live, in order to skip ssl validation use 8080 port
        #       # Because kubelete will check like this: curl http://EPHEMERAL_IP:8080/frontend/health
        #     path: /glogger-audit-api/health
        #     port: 8080
        #   initialDelaySeconds: 30
        #   periodSeconds: 5
        # readinessProbe:
        #   httpGet:
        #       # IMPORTANT this uri must return 200 status and keycloack security doesn't apply on that uri
        #       # kubelet will check if the app is ready to send traffic, in order to skip ssl validation use 8080 port
        #       # Because kubelete will check like this: curl http://EPHEMERAL_IP:8080/frontend/health
        #     path: /glogger-audit-api/health
        #     port: 8080
        #   initialDelaySeconds: 30
        #   periodSeconds: 15  #Because for livenessProbe the periodseconds is 5 then
              # by default failurethreshold is 3 then 3*5 = 15 s
            # It means a new pod will become not ready after 15 seconds       
        resources:
          requests:
            cpu: "500m"
            memory: "1024M"
          limits:
            memory: "1024Mi"
            cpu: "500m"
        # [END ASSIGN RESOURCES]
        # [START VARIABLES]
        # In this section you can initialize env variables it will be helpful in order to avoid sticky configurations inside container or your code
        # a good example could be the database user and password 
        # cloud sql configurations.
        # You can create configmap objets and read them in order to initialize the variable like this
        #
        # - name: VARIABLE_1
        #   valueFrom:
        #     configMapKeyRef:
        #       key: CUSTOM_VARIABLE1
        #       name: configmap-config-microserviceservice # configmap name
        env:
        - name:  ENVVARNAME
          value:  ENVVARVALUE       
        # [END VARIABLES]
        # [START PORTS]
        # Remember the docker images should have a sentente like this : EXPOSE 443
        # You can expose more than one port if you need.
        ports:
        - containerPort:  443
          name: web-port
        volumeMounts:
          - name: cert-telus-volumen
            mountPath: /etc/ssl/private/cert-telus/
          - name: tls-ti-certs-secret
            mountPath: /etc/ssl/private/tls-ti-certs-secret/
      volumes:
        - name: cert-telus-volumen
          secret:
            secretName: ti-certificates
        - name: tls-ti-certs-secret
          secret:
            secretName: tls-ti-certs-secret           